# IV Crush 2.0 - Complete Implementation Guide

**Companion:** See `2.0_OVERVIEW.md` for architecture and timeline  
**Version:** 2.0-Complete with Phases 1-4

This document contains complete, runnable code for all components including production-hardening layers.

---

## PART 1: DAYS 1-21 MVP IMPLEMENTATION

### Project Setup

```bash
# From project root
mkdir -p 2.0/{src/{domain,config,infrastructure/{api,database/repositories,cache},application/{metrics,services},utils},tests/{unit,integration,performance},scripts,data,logs}

# Create __init__.py files
find 2.0/src -type d -exec touch {}/__init__.py \;
find 2.0/tests -type d -exec touch {}/__init__.py \;
```

### Core Dependencies

```toml
# pyproject.toml
[project]
name = "iv-crush-2"
version = "2.0.0"
requires-python = "3.11"

dependencies = [
    "requests>=2.32.0",
    "python-dotenv>=1.2.0",
    "numpy>=2.0.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.0.0",
    "pytest-cov>=4.0.0",
    "pytest-mock>=3.10.0",
]
```

### Domain Types

```python
# src/domain/types.py

from dataclasses import dataclass
from decimal import Decimal
from datetime import date, datetime, timezone
from zoneinfo import ZoneInfo
from typing import Dict, Optional, List
from enum import Enum

# Core value objects
@dataclass(frozen=True)
class Money:
    amount: Decimal
    
    def __init__(self, amount: float | Decimal | str):
        object.__setattr__(self, 'amount', Decimal(str(amount)))
    
    def __add__(self, other):
        return Money(self.amount + other.amount)
    
    def __sub__(self, other):
        return Money(self.amount - other.amount)

@dataclass(frozen=True)
class Percentage:
    value: float
    
    def __init__(self, value: float):
        if value < -100 or value > 1000:
            raise ValueError(f"Invalid percentage: {value}")
        object.__setattr__(self, 'value', float(value))

@dataclass(frozen=True)
class Strike:
    price: Decimal
    
    def __init__(self, price: float | Decimal | str):
        object.__setattr__(self, 'price', Decimal(str(price)))

@dataclass(frozen=True)
class OptionQuote:
    bid: Money
    ask: Money
    implied_volatility: Optional[Percentage] = None
    open_interest: int = 0
    volume: int = 0
    
    @property
    def mid(self) -> Money:
        return Money((self.bid.amount + self.ask.amount) / 2)
    
    @property
    def spread_pct(self) -> float:
        if self.mid.amount == 0:
            return 0
        return float((self.ask.amount - self.bid.amount) / self.mid.amount * 100)

@dataclass(frozen=True)
class OptionChain:
    ticker: str
    expiration: date
    stock_price: Money
    calls: Dict[Strike, OptionQuote]
    puts: Dict[Strike, OptionQuote]
    
    def atm_strike(self) -> Strike:
        """Find closest ATM strike using binary search."""
        import bisect
        strikes = sorted(self.strikes, key=lambda s: float(s.price))
        idx = bisect.bisect_left([float(s.price) for s in strikes], float(self.stock_price.amount))
        if idx == 0:
            return strikes[0]
        if idx == len(strikes):
            return strikes[-1]
        return strikes[idx-1] if abs(float(strikes[idx-1].price) - float(self.stock_price.amount)) < abs(float(strikes[idx].price) - float(self.stock_price.amount)) else strikes[idx]
    
    @property
    def strikes(self) -> List[Strike]:
        return sorted(set(self.calls.keys()) | set(self.puts.keys()))
    
    def get_straddle(self, strike: Strike) -> tuple[OptionQuote, OptionQuote]:
        call = self.calls[strike]
        put = self.puts[strike]
        return call, put

@dataclass(frozen=True)
class ImpliedMove:
    ticker: str
    expiration: date
    stock_price: Money
    atm_strike: Strike
    straddle_cost: Money
    implied_move_pct: Percentage
    upper_bound: Money
    lower_bound: Money

@dataclass(frozen=True)
class HistoricalMove:
    ticker: str
    earnings_date: date
    prev_close: Money
    earnings_open: Money
    earnings_high: Money
    earnings_low: Money
    earnings_close: Money
    intraday_move_pct: Percentage
    gap_move_pct: Percentage
    close_move_pct: Percentage

@dataclass(frozen=True)
class VRPResult:
    ticker: str
    expiration: date
    implied_move_pct: Percentage
    historical_mean_move_pct: Percentage
    vrp_ratio: float
    edge_score: float
    recommendation: str  # 'excellent', 'good', 'marginal', 'skip'

@dataclass(frozen=True)
class TickerAnalysis:
    ticker: str
    earnings_date: date
    entry_time: datetime
    implied_move: ImpliedMove
    vrp: VRPResult
    recommendation: str
```

### Error Handling

```python
# src/domain/errors.py

from dataclasses import dataclass
from enum import Enum
from typing import TypeVar, Union, Generic, Callable, Any

class ErrorCode(Enum):
    RATELIMIT = "RATELIMIT"
    NODATA = "NODATA"
    INVALID = "INVALID"
    TIMEOUT = "TIMEOUT"
    EXTERNAL = "EXTERNAL"
    DBERROR = "DBERROR"

@dataclass
class AppError:
    code: ErrorCode
    message: str
    context: dict = None
    
    def __str__(self):
        return f"{self.code.value}: {self.message}"

T = TypeVar('T')
E = TypeVar('E', bound=AppError)

@dataclass
class Result(Generic[T, E]):
    value: T = None
    error: E = None
    
    @classmethod
    def Ok(cls, value: T) -> 'Result[T, AppError]':
        return Result(value=value)
    
    @classmethod
    def Err(cls, error: AppError) -> 'Result[T, AppError]':
        return Result(error=error)
    
    @property
    def is_ok(self) -> bool:
        return self.value is not None
    
    @property
    def is_err(self) -> bool:
        return self.error is not None
    
    def unwrap(self) -> T:
        if self.is_err:
            raise Exception(str(self.error))
        return self.value
    
    def unwrap_err(self) -> E:
        if self.is_ok:
            raise Exception("Result is Ok, not Err")
        return self.error

Ok = Result.Ok
Err = Result.Err
```

### Infrastructure - APIs

```python
# src/infrastructure/api/tradier.py

import requests
import logging
from datetime import date
from typing import Dict
from src.domain.types import Money, Strike, OptionChain, OptionQuote, Percentage
from src.domain.errors import Result, AppError, Ok, Err, ErrorCode
from src.domain.protocols import OptionsDataProvider

logger = logging.getLogger(__name__)

class TradierAPI(OptionsDataProvider):
    def __init__(self, api_key: str, base_url: str = "https://api.tradier.com/v1"):
        self.api_key = api_key
        self.base_url = base_url
        self.headers = {
            'Authorization': f'Bearer {api_key}',
            'Accept': 'application/json'
        }
    
    def get_stock_price(self, ticker: str) -> Result[Money, AppError]:
        """Get current stock price."""
        try:
            response = requests.get(
                f"{self.base_url}/markets/quotes",
                params={'symbols': ticker},
                headers=self.headers,
                timeout=10
            )
            response.raise_for_status()
            
            data = response.json()
            quotes = data.get('quotes', {}).get('quote', [])
            if not isinstance(quotes, list):
                quotes = [quotes]
            
            if not quotes or not quotes[0].get('last'):
                return Err(AppError(ErrorCode.NODATA, f"No price for {ticker}"))
            
            last = float(quotes[0]['last'])
            return Ok(Money(last))
        
        except requests.exceptions.Timeout:
            return Err(AppError(ErrorCode.TIMEOUT, f"Timeout fetching {ticker}"))
        except Exception as e:
            logger.error(f"Error fetching price: {e}")
            return Err(AppError(ErrorCode.EXTERNAL, str(e)))
    
    def get_option_chain(self, ticker: str, expiration: date) -> Result[OptionChain, AppError]:
        """Get option chain for expiration."""
        try:
            # Get stock price first
            price_result = self.get_stock_price(ticker)
            if price_result.is_err:
                return Err(price_result.error)
            stock_price = price_result.value
            
            # Get option chain
            response = requests.get(
                f"{self.base_url}/markets/options/chains",
                params={
                    'symbol': ticker,
                    'expiration': expiration.isoformat()
                },
                headers=self.headers,
                timeout=10
            )
            response.raise_for_status()
            
            data = response.json()
            options = data.get('options', {}).get('option', [])
            if not isinstance(options, list):
                options = [options]
            
            if not options:
                return Err(AppError(ErrorCode.NODATA, f"No options for {ticker}"))
            
            # Parse options into calls/puts
            calls = {}
            puts = {}
            
            for opt in options:
                if not opt.get('bid') or not opt.get('ask'):
                    continue
                
                strike = Strike(float(opt['strike']))
                iv = Percentage(float(opt.get('option_iv', 0))) if opt.get('option_iv') else None
                
                quote = OptionQuote(
                    bid=Money(float(opt['bid'])),
                    ask=Money(float(opt['ask'])),
                    implied_volatility=iv,
                    open_interest=int(opt.get('open_interest', 0)),
                    volume=int(opt.get('volume', 0))
                )
                
                if opt['option_type'] == 'call':
                    calls[strike] = quote
                else:
                    puts[strike] = quote
            
            if not calls or not puts:
                return Err(AppError(ErrorCode.NODATA, "Missing calls or puts"))
            
            chain = OptionChain(
                ticker=ticker,
                expiration=expiration,
                stock_price=stock_price,
                calls=calls,
                puts=puts
            )
            
            return Ok(chain)
        
        except requests.exceptions.Timeout:
            return Err(AppError(ErrorCode.TIMEOUT, f"Timeout fetching chain"))
        except Exception as e:
            logger.error(f"Error fetching chain: {e}")
            return Err(AppError(ErrorCode.EXTERNAL, str(e)))
```

### Core Metrics - Implied Move

```python
# src/application/metrics/implied_move.py

import logging
from datetime import date
from src.domain.types import Money, Percentage, Strike, ImpliedMove, OptionChain
from src.domain.errors import Result, AppError, Ok, Err, ErrorCode
from src.domain.protocols import OptionsDataProvider

logger = logging.getLogger(__name__)

class ImpliedMoveCalculator:
    def __init__(self, provider: OptionsDataProvider):
        self.provider = provider
    
    def calculate(self, ticker: str, expiration: date) -> Result[ImpliedMove, AppError]:
        """Calculate implied move from ATM straddle."""
        
        # Get option chain
        chain_result = self.provider.get_option_chain(ticker, expiration)
        if chain_result.is_err:
            return Err(chain_result.error)
        
        chain = chain_result.value
        
        # Find ATM strike
        atm_strike = chain.atm_strike()
        
        # Get straddle
        if atm_strike not in chain.calls or atm_strike not in chain.puts:
            return Err(AppError(ErrorCode.NODATA, "ATM strike missing"))
        
        call = chain.calls[atm_strike]
        put = chain.puts[atm_strike]
        
        # Straddle cost
        straddle_cost = call.mid + put.mid
        
        # Implied move percentage
        stock_price = chain.stock_price.amount
        if stock_price <= 0:
            return Err(AppError(ErrorCode.INVALID, "Invalid stock price"))
        
        implied_move_pct = Percentage(float(straddle_cost.amount / stock_price * 100))
        
        # Bounds
        upper_bound = Money(stock_price + straddle_cost.amount)
        lower_bound = Money(stock_price - straddle_cost.amount)
        
        if lower_bound.amount <= 0:
            return Err(AppError(ErrorCode.INVALID, "Lower bound negative"))
        
        result = ImpliedMove(
            ticker=ticker,
            expiration=expiration,
            stock_price=chain.stock_price,
            atm_strike=atm_strike,
            straddle_cost=straddle_cost,
            implied_move_pct=implied_move_pct,
            upper_bound=upper_bound,
            lower_bound=lower_bound
        )
        
        logger.info(f"{ticker}: Implied move {implied_move_pct.value:.2f}%")
        return Ok(result)
```

### Core Metrics - VRP

```python
# src/application/metrics/vrp.py

import logging
import numpy as np
from datetime import date
from src.domain.types import Money, Percentage, VRPResult, HistoricalMove, ImpliedMove
from src.domain.errors import Result, AppError, Ok, Err, ErrorCode

logger = logging.getLogger(__name__)

class VRPCalculator:
    def __init__(self, threshold_excellent=2.0, threshold_good=1.5, threshold_marginal=1.2):
        self.thresholds = {
            'excellent': threshold_excellent,
            'good': threshold_good,
            'marginal': threshold_marginal
        }
    
    def calculate(
        self,
        ticker: str,
        expiration: date,
        implied_move: ImpliedMove,
        historical_moves: list[HistoricalMove]
    ) -> Result[VRPResult, AppError]:
        """Calculate VRP ratio and recommendation."""
        
        if not historical_moves or len(historical_moves) < 4:
            return Err(AppError(ErrorCode.NODATA, "Need 4+ quarters of data"))
        
        # Calculate mean historical move
        historical_pcts = [float(m.intraday_move_pct.value) for m in historical_moves]
        mean_move = np.mean(historical_pcts)
        
        if mean_move <= 0:
            return Err(AppError(ErrorCode.INVALID, "Invalid historical moves"))
        
        # VRP ratio
        implied_pct = float(implied_move.implied_move_pct.value)
        vrp_ratio = implied_pct / mean_move
        
        # Edge score (Sharpe-like)
        mad = np.median(np.abs(np.array(historical_pcts) - mean_move))
        consistency = mad / mean_move if mean_move > 0 else 999
        edge_score = vrp_ratio / (1 + consistency)
        
        # Recommendation
        if vrp_ratio >= self.thresholds['excellent']:
            rec = 'excellent'
        elif vrp_ratio >= self.thresholds['good']:
            rec = 'good'
        elif vrp_ratio >= self.thresholds['marginal']:
            rec = 'marginal'
        else:
            rec = 'skip'
        
        result = VRPResult(
            ticker=ticker,
            expiration=expiration,
            implied_move_pct=implied_move.implied_move_pct,
            historical_mean_move_pct=Percentage(mean_move),
            vrp_ratio=vrp_ratio,
            edge_score=edge_score,
            recommendation=rec
        )
        
        logger.info(f"{ticker}: VRP {vrp_ratio:.2f}x ({rec})")
        return Ok(result)
```

### Dependency Injection Container

```python
# src/container.py

import logging
from pathlib import Path
from src.config.config import Config
from src.infrastructure.api.tradier import TradierAPI
from src.infrastructure.api.alpha_vantage import AlphaVantageAPI
from src.infrastructure.cache.memory_cache import MemoryCache
from src.infrastructure.database.repositories import EarningsRepository, MetadataRepository
from src.application.metrics.implied_move import ImpliedMoveCalculator
from src.application.metrics.vrp import VRPCalculator
from src.application.services.analyzer import TickerAnalyzer

logger = logging.getLogger(__name__)

class Container:
    def __init__(self, config: Config):
        self.config = config
        self._tradier = None
        self._alphavantage = None
        self._cache = None
        self._earnings_repo = None
        self._analyzer = None
    
    @property
    def tradier(self) -> TradierAPI:
        if self._tradier is None:
            self._tradier = TradierAPI(self.config.api.tradier_api_key)
        return self._tradier
    
    @property
    def alphavantage(self) -> AlphaVantageAPI:
        if self._alphavantage is None:
            self._alphavantage = AlphaVantageAPI(self.config.api.alpha_vantage_key)
        return self._alphavantage
    
    @property
    def cache(self) -> MemoryCache:
        if self._cache is None:
            self._cache = MemoryCache(ttl_seconds=30)
        return self._cache
    
    @property
    def earnings_repository(self) -> EarningsRepository:
        if self._earnings_repo is None:
            self._earnings_repo = EarningsRepository(str(self.config.database.path))
        return self._earnings_repo
    
    @property
    def implied_move_calculator(self) -> ImpliedMoveCalculator:
        return ImpliedMoveCalculator(self.tradier)
    
    @property
    def vrp_calculator(self) -> VRPCalculator:
        return VRPCalculator(
            threshold_excellent=self.config.thresholds.vrp_excellent,
            threshold_good=self.config.thresholds.vrp_good,
            threshold_marginal=self.config.thresholds.vrp_marginal
        )
    
    @property
    def analyzer(self) -> TickerAnalyzer:
        if self._analyzer is None:
            self._analyzer = TickerAnalyzer(
                implied_move_calc=self.implied_move_calculator,
                vrp_calc=self.vrp_calculator,
                earnings_repo=self.earnings_repository
            )
        return self._analyzer
```

---

## PART 2: DAYS 22-28 PHASE 1 - CRITICAL RESILIENCE

### A. Retry Decorator

```python
# src/utils/retry.py

import asyncio
import random
import logging
import time
from functools import wraps
from typing import Callable, TypeVar

logger = logging.getLogger(__name__)
T = TypeVar("T")

def async_retry(max_attempts=3, backoff_base=2.0, max_backoff=60.0, jitter=True, exceptions=None):
    """Async retry with exponential backoff."""
    if exceptions is None:
        exceptions = (Exception,)
    
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args, **kwargs):
            last_exception = None
            
            for attempt in range(max_attempts):
                try:
                    return await func(*args, **kwargs)
                except exceptions as e:
                    last_exception = e
                    
                    if attempt == max_attempts - 1:
                        logger.error(f"{func.__name__} failed after {max_attempts} attempts: {e}")
                        raise
                    
                    backoff = min(backoff_base ** attempt, max_backoff)
                    if jitter:
                        backoff += random.uniform(0, backoff * 0.1)
                    
                    logger.warning(f"{func.__name__} retry in {backoff:.2f}s (attempt {attempt+1}/{max_attempts}): {e}")
                    await asyncio.sleep(backoff)
            
            raise last_exception
        
        return wrapper
    return decorator

def sync_retry(max_attempts=3, backoff_base=2.0, max_backoff=60.0, jitter=True, exceptions=None):
    """Sync retry with exponential backoff."""
    if exceptions is None:
        exceptions = (Exception,)
    
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs):
            last_exception = None
            
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    last_exception = e
                    
                    if attempt == max_attempts - 1:
                        logger.error(f"{func.__name__} failed after {max_attempts} attempts: {e}")
                        raise
                    
                    backoff = min(backoff_base ** attempt, max_backoff)
                    if jitter:
                        backoff += random.uniform(0, backoff * 0.1)
                    
                    logger.warning(f"{func.__name__} retry in {backoff:.2f}s (attempt {attempt+1}/{max_attempts}): {e}")
                    time.sleep(backoff)
            
            raise last_exception
        
        return wrapper
    return decorator
```

### B. Circuit Breaker

```python
# src/utils/circuit_breaker.py

import logging
import time
from datetime import datetime, timedelta
from enum import Enum
from typing import Callable, TypeVar

logger = logging.getLogger(__name__)
T = TypeVar("T")

class CircuitState(Enum):
    CLOSED = "closed"
    OPEN = "open"
    HALF_OPEN = "half_open"

class CircuitBreakerOpenError(Exception):
    pass

class CircuitBreaker:
    """Circuit breaker for API resilience."""
    
    def __init__(self, name: str, failure_threshold=5, recovery_timeout=60):
        self.name = name
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.last_failure_time = None
    
    def call(self, func: Callable, *args, **kwargs):
        """Execute function with circuit breaker protection."""
        
        if self.state == CircuitState.OPEN:
            if self._should_attempt_reset():
                self.state = CircuitState.HALF_OPEN
                logger.info(f"Circuit {self.name} entering HALF_OPEN")
            else:
                raise CircuitBreakerOpenError(f"Circuit {self.name} is OPEN")
        
        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise
    
    def _on_success(self):
        if self.state == CircuitState.HALF_OPEN:
            logger.info(f"Circuit {self.name} recovered")
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.last_failure_time = None
    
    def _on_failure(self):
        self.failure_count += 1
        self.last_failure_time = datetime.now()
        
        if self.failure_count >= self.failure_threshold:
            logger.error(f"Circuit {self.name} opening after {self.failure_count} failures")
            self.state = CircuitState.OPEN
    
    def _should_attempt_reset(self) -> bool:
        if not self.last_failure_time:
            return True
        elapsed = datetime.now() - self.last_failure_time
        return elapsed >= timedelta(seconds=self.recovery_timeout)
```

### C. Correlation ID Tracing

```python
# src/utils/tracing.py

import uuid
import logging
from contextvars import ContextVar
from typing import Optional

correlation_id: ContextVar[Optional[str]] = ContextVar("correlation_id", default=None)

class CorrelationIdFilter(logging.Filter):
    def filter(self, record):
        cid = correlation_id.get() or "?"
        record.correlation_id = cid[:8]
        return True

def get_correlation_id() -> str:
    cid = correlation_id.get()
    if cid is None:
        cid = str(uuid.uuid4())
        correlation_id.set(cid)
    return cid

def set_correlation_id(cid: str):
    correlation_id.set(cid)
```

### D. Health Check Service

```python
# src/application/services/health.py

import asyncio
import time
import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, Optional

logger = logging.getLogger(__name__)

@dataclass
class ServiceHealth:
    name: str
    healthy: bool
    latency_ms: float
    error: Optional[str] = None
    checked_at: datetime = None
    
    def __post_init__(self):
        if self.checked_at is None:
            self.checked_at = datetime.now()
    
    def __str__(self):
        status = "‚úÖ UP" if self.healthy else "‚ùå DOWN"
        return f"{self.name:20} {status:8} {self.latency_ms:.1f}ms"

class HealthCheckService:
    def __init__(self, container):
        self.container = container
        self.timeout_seconds = 5
    
    async def check_all(self) -> Dict[str, ServiceHealth]:
        """Check all services."""
        checks = {
            "tradier": self._check_tradier(),
            "database": self._check_database(),
            "cache": self._check_cache(),
        }
        
        results = await asyncio.gather(*checks.values(), return_exceptions=False)
        return dict(zip(checks.keys(), results))
    
    async def _check_tradier(self) -> ServiceHealth:
        start = time.perf_counter()
        try:
            result = self.container.tradier.get_stock_price("AAPL")
            if result.is_err:
                raise result.error
            latency = (time.perf_counter() - start) * 1000
            return ServiceHealth(name="tradier", healthy=True, latency_ms=latency)
        except Exception as e:
            latency = (time.perf_counter() - start) * 1000
            return ServiceHealth(name="tradier", healthy=False, latency_ms=latency, error=str(e))
    
    async def _check_database(self) -> ServiceHealth:
        start = time.perf_counter()
        try:
            import sqlite3
            dbpath = str(self.container.config.database.path)
            with sqlite3.connect(dbpath, timeout=self.timeout_seconds):
                pass
            latency = (time.perf_counter() - start) * 1000
            return ServiceHealth(name="database", healthy=True, latency_ms=latency)
        except Exception as e:
            latency = (time.perf_counter() - start) * 1000
            return ServiceHealth(name="database", healthy=False, latency_ms=latency, error=str(e))
    
    async def _check_cache(self) -> ServiceHealth:
        start = time.perf_counter()
        try:
            self.container.cache.set("_health", {"test": True})
            result = self.container.cache.get("_health")
            if result is None:
                raise ValueError("Cache returned None")
            latency = (time.perf_counter() - start) * 1000
            return ServiceHealth(name="cache", healthy=True, latency_ms=latency)
        except Exception as e:
            latency = (time.perf_counter() - start) * 1000
            return ServiceHealth(name="cache", healthy=False, latency_ms=latency, error=str(e))
```

### E. Async Application Layer

```python
# src/application/async_metrics/vrp_analyzer_async.py

import asyncio
import logging
from datetime import date
from typing import List
from src.application.services.analyzer import TickerAnalyzer
from src.domain.types import TickerAnalysis
from src.domain.errors import Result, AppError

logger = logging.getLogger(__name__)

class AsyncTickerAnalyzer:
    def __init__(self, sync_analyzer: TickerAnalyzer):
        self.sync_analyzer = sync_analyzer
    
    async def analyze_many(
        self,
        tickers: List[str],
        earnings_date: date,
        expiration: date,
        max_concurrent: int = 10
    ) -> List[tuple[str, Result[TickerAnalysis, AppError]]]:
        """Analyze multiple tickers concurrently."""
        
        semaphore = asyncio.Semaphore(max_concurrent)
        
        async def analyze_with_limit(ticker):
            async with semaphore:
                loop = asyncio.get_event_loop()
                result = await loop.run_in_executor(
                    None,
                    lambda: self.sync_analyzer.analyze(ticker, earnings_date, expiration)
                )
                return ticker, result
        
        tasks = [analyze_with_limit(ticker) for ticker in tickers]
        results = await asyncio.gather(*tasks, return_exceptions=False)
        
        return results
```

### F. Integration into Container

```python
# src/container.py - ADD THESE

from src.utils.circuit_breaker import CircuitBreaker
from src.application.services.health import HealthCheckService
from src.application.async_metrics.vrp_analyzer_async import AsyncTickerAnalyzer

class Container:
    # ... existing code ...
    
    @property
    def health_check_service(self) -> HealthCheckService:
        return HealthCheckService(self)
    
    @property
    def async_analyzer(self) -> AsyncTickerAnalyzer:
        return AsyncTickerAnalyzer(self.analyzer)
    
    def setup_api_resilience(self):
        """Wrap APIs with circuit breaker."""
        tradier_breaker = CircuitBreaker("tradier", failure_threshold=5)
        original_get_chain = self.tradier.get_option_chain
        
        def get_chain_with_breaker(ticker, exp):
            return tradier_breaker.call(original_get_chain, ticker, exp)
        
        self.tradier.get_option_chain = get_chain_with_breaker
```

### CLI Script: Health Check

```python
# scripts/health_check.py

import asyncio
import logging
from src.config.config import Config
from src.container import Container
from src.utils.logging import setup_logging

logger = logging.getLogger(__name__)

async def main():
    setup_logging("INFO")
    config = Config.from_env()
    container = Container(config)
    
    health_service = container.health_check_service
    results = await health_service.check_all()
    
    print("\nüìä IV Crush 2.0 - System Health")
    print("=" * 60)
    
    all_healthy = all(h.healthy for h in results.values())
    
    for service in results.values():
        print(service)
    
    print("=" * 60)
    print(f"Status: {'‚úÖ HEALTHY' if all_healthy else '‚ùå UNHEALTHY'}")
    
    return 0 if all_healthy else 1

if __name__ == "__main__":
    exit(asyncio.run(main()))
```

---

## PART 3: DAYS 29-35 PHASE 2 - PERSISTENCE & OPERATIONS

### A. Persistent Hybrid Cache

```python
# src/infrastructure/cache/hybrid_cache.py

import sqlite3
import logging
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional

logger = logging.getLogger(__name__)

class HybridCache:
    def __init__(self, db_path: Path, l1_ttl: int = 30, l2_ttl: int = 300):
        self.db_path = db_path
        self.l1_ttl = l1_ttl
        self.l2_ttl = l2_ttl
        self.l1 = {}
        self.l1_timestamps = {}
        self._init_db()
    
    def _init_db(self):
        with sqlite3.connect(self.db_path) as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS cache (
                    key TEXT PRIMARY KEY,
                    value BLOB NOT NULL,
                    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            conn.execute('CREATE INDEX IF NOT EXISTS idx_timestamp ON cache(timestamp)')
    
    def get(self, key: str):
        now = datetime.now()
        
        # L1 check
        if key in self.l1:
            stored_time = self.l1_timestamps.get(key)
            if stored_time and (now - stored_time).total_seconds() < self.l1_ttl:
                logger.debug(f"Cache L1 hit: {key}")
                return self.l1[key]
            else:
                del self.l1[key]
                del self.l1_timestamps[key]
        
        # L2 check
        try:
            with sqlite3.connect(self.db_path) as conn:
                row = conn.execute(
                    'SELECT value, timestamp FROM cache WHERE key = ?',
                    (key,)
                ).fetchone()
            
            if row:
                value, timestamp_str = row
                stored_time = datetime.fromisoformat(timestamp_str)
                
                if (now - stored_time).total_seconds() < self.l2_ttl:
                    logger.debug(f"Cache L2 hit: {key}")
                    self.l1[key] = value
                    self.l1_timestamps[key] = now
                    return value
                else:
                    with sqlite3.connect(self.db_path) as conn:
                        conn.execute('DELETE FROM cache WHERE key = ?', (key,))
        except sqlite3.Error as e:
            logger.warning(f"L2 cache error: {e}")
        
        logger.debug(f"Cache miss: {key}")
        return None
    
    def set(self, key: str, value) -> None:
        now = datetime.now()
        
        self.l1[key] = value
        self.l1_timestamps[key] = now
        
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute(
                    'INSERT OR REPLACE INTO cache (key, value, timestamp) VALUES (?, ?, ?)',
                    (key, value, now.isoformat())
                )
        except sqlite3.Error as e:
            logger.error(f"Failed to write to L2 cache: {e}")
```

### B. Configuration Validation

```python
# src/config/validation.py

import logging
import os
from pathlib import Path
from src.config.config import Config

logger = logging.getLogger(__name__)

class ConfigurationError(Exception):
    pass

def validate_configuration(config: Config) -> None:
    """Validate all configuration at startup."""
    errors = []
    
    # API Keys
    if not config.api.tradier_api_key or config.api.tradier_api_key.strip() == "":
        errors.append("TRADIER_API_KEY is missing")
    
    if not config.api.alpha_vantage_key or config.api.alpha_vantage_key.strip() == "":
        errors.append("ALPHA_VANTAGE_KEY is missing")
    
    # Database
    db_path = config.database.path
    db_parent = Path(db_path).parent
    
    if not db_parent.exists():
        errors.append(f"Database directory does not exist: {db_parent}")
    elif not os.access(db_parent, os.W_OK):
        errors.append(f"Database directory is not writable: {db_parent}")
    
    # Thresholds
    if config.thresholds.vrp_excellent <= config.thresholds.vrp_good:
        errors.append(f"VRP thresholds invalid: excellent ({config.thresholds.vrp_excellent}) must be > good ({config.thresholds.vrp_good})")
    
    if errors:
        for error in errors:
            logger.error(f"Configuration error: {error}")
        raise ConfigurationError(f"{len(errors)} configuration error(s)")
    
    logger.info("Configuration validated successfully")
```

### C. Performance Tracking

```python
# src/utils/performance.py

import time
import logging
from functools import wraps
from collections import defaultdict

logger = logging.getLogger(__name__)

class PerformanceMonitor:
    def __init__(self):
        self.metrics = defaultdict(list)
        self.thresholds = {
            "analyze_ticker": 1000,
            "get_option_chain": 500,
            "calculate_vrp": 200,
        }
    
    def track(self, func_name: str, duration_ms: float) -> None:
        self.metrics[func_name].append(duration_ms)
        
        threshold = self.thresholds.get(func_name, 10000)
        if duration_ms > threshold:
            logger.warning(f"SLOW: {func_name} took {duration_ms:.1f}ms (threshold: {threshold}ms)")

_monitor = PerformanceMonitor()

def track_performance(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        try:
            result = func(*args, **kwargs)
            return result
        finally:
            elapsed_ms = (time.perf_counter() - start) * 1000
            _monitor.track(func.__name__, elapsed_ms)
    return wrapper
```

### D. Updated API with Retry

```python
# src/infrastructure/api/tradier.py - ADD RETRY

from src.utils.retry import sync_retry

class TradierAPI(OptionsDataProvider):
    @sync_retry(max_attempts=3, backoff_base=2)
    def get_stock_price(self, ticker: str) -> Result[Money, AppError]:
        # Implementation with automatic retry...
        pass
    
    @sync_retry(max_attempts=3, backoff_base=2)
    def get_option_chain(self, ticker: str, expiration: date) -> Result[OptionChain, AppError]:
        # Implementation with automatic retry...
        pass
```

---

## PART 4: DAYS 36-42 PHASE 3 - PRODUCTION DEPLOYMENT

### A. Edge Case Tests

```python
# tests/unit/test_edge_cases.py

import pytest
from src.application.metrics.implied_move import ImpliedMoveCalculator
from src.domain.types import Money

def test_stock_price_zero():
    """Handle zero stock price gracefully."""
    mock_provider = MockProvider()
    mock_provider.set_stock_price(Money(0))
    
    calculator = ImpliedMoveCalculator(mock_provider)
    result = calculator.calculate('DEAD', date(2025, 1, 31))
    
    assert result.is_err

def test_single_quarter_history():
    """Insufficient historical data."""
    from src.application.metrics.consistency import ConsistencyAnalyzer
    
    moves = [HistoricalMove(...)]  # Only 1
    analyzer = ConsistencyAnalyzer()
    result = analyzer.analyze(moves)
    
    assert result.is_err

def test_extreme_iv_crush_10x():
    """Implied move 10x historical."""
    from src.application.metrics.vrp import VRPCalculator
    
    implied = ImpliedMove(..., implied_move_pct=Percentage(50))
    moves = [HistoricalMove(..., intraday_move_pct=Percentage(5)) for _ in range(4)]
    
    calc = VRPCalculator()
    result = calc.calculate('TSLA', date(2025, 1, 31), implied, moves)
    
    assert result.is_ok
    assert result.value.vrp_ratio == 10.0
```

### B. Load Testing

```python
# tests/performance/test_load.py

import pytest
import time
import asyncio
from src.container import Container

@pytest.mark.performance
def test_scan_100_tickers():
    """100 tickers should complete in < 10 seconds."""
    container = Container(Config.from_env())
    
    tickers = [f"TICK{i:03d}" for i in range(100)]
    
    start = time.perf_counter()
    results = asyncio.run(
        container.async_analyzer.analyze_many(tickers, date.today(), date.today() + timedelta(days=7))
    )
    elapsed = time.perf_counter() - start
    
    assert elapsed < 10.0, f"Took {elapsed:.1f}s, target < 10s"
    print(f"‚úì 100 tickers: {elapsed:.1f}s ({100/elapsed:.1f} tickers/sec)")
```

### C. Deployment Runbook

```markdown
# DEPLOYMENT.md

## Pre-Deployment Checklist

- [ ] Python 3.11+ installed
- [ ] Virtual environment created
- [ ] Dependencies installed
- [ ] Health check passes: `python scripts/health_check.py`
- [ ] Single ticker analysis works: `python scripts/analyze.py AAPL`

## Deployment Steps

1. Setup environment
2. Run health check
3. Verify smoke tests
4. Backfill initial data
5. Deploy to production
6. Monitor first 100+ tickers

## Monitoring

- Track: API latency, error rates, cache hit rate
- Alert: If any metric > 20% off baseline
```

---

## PART 5: DAYS 43-46 PHASE 4 - ALGORITHMIC OPTIMIZATION

### Enhanced Skew Analysis

```python
# src/application/metrics/skew_enhanced.py

import numpy as np

class SkewAnalyzerEnhanced:
    def analyze_skew_curve(self, ticker: str, expiration: date):
        """Polynomial-fitted skew analysis."""
        
        chain = self.provider.get_option_chain(ticker, expiration).value
        stock_price = float(chain.stock_price.amount)
        
        # Collect multiple OTM points
        skew_points = []
        for strike in chain.strikes:
            strike_price = float(strike.price)
            if abs(strike_price - stock_price) / stock_price < 0.02:
                continue
            
            put_iv = chain.puts[strike].implied_volatility.value
            call_iv = chain.calls[strike].implied_volatility.value
            distance = (strike_price - stock_price) / stock_price
            skew = put_iv - call_iv
            skew_points.append((distance, skew))
        
        # Fit polynomial
        distances, skews = zip(*skew_points)
        coeffs = np.polyfit(distances, skews, 2)
        
        skew_atm = coeffs[2]  # Value at x=0
        curvature = 2 * coeffs[0]
        
        return {
            'skew_atm': skew_atm,
            'curvature': curvature,
            'strength': 'smile' if curvature > 1 else 'smirk'
        }
```

---

## Testing Framework

```python
# tests/conftest.py

import pytest
from datetime import date
from src.config.config import Config
from src.container import Container

@pytest.fixture
def config():
    return Config.from_env()

@pytest.fixture
def container(config):
    return Container(config)

@pytest.fixture
def today():
    return date.today()
```

---

## Running Tests

```bash
# All tests
pytest tests/ -v

# With coverage
pytest tests/ --cov=src --cov-report=html

# Only unit tests
pytest tests/unit/ -v

# Only integration tests
pytest tests/integration/ -v

# Performance tests
pytest tests/performance/ -v -s
```

---

**Implementation Complete**  
Ready to build!
