# IV Crush 2.0 System - Overview

**Date:** 2025-11-12
**Status:** Production-Ready Architecture

---

## Executive Summary

Complete redesign of IV crush trading system with production-ready architecture. Focuses on **quantitative volatility risk premium (VRP)** strategy with clean code, full testing, and zero technical debt.

**Timeline:** 18 days to production
**Architecture:** Dependency injection, type safety, comprehensive error handling
**Testing:** 80%+ coverage with unit and integration tests

---

## Strategy Overview

### Core Thesis: Volatility Risk Premium (VRP)

**What:** Sell options when implied volatility is inflated relative to historical realized moves.

**Entry:** 3:00-4:00 PM ET on trading day
- **AMC (After Market Close):** Enter same day, earnings after 4 PM
- **BMO (Before Market Open):** Enter day before, earnings next morning

**Exit:** Next day at 9:30 AM after IV crush

**Edge:** VRP Ratio = Implied Move / Historical Mean Move
- **Excellent:** 2.0x+ (implied move is double historical average)
- **Good:** 1.5-2.0x
- **Skip:** <1.5x

### Why 2.0 System?

**Old System (1.0) Issues:**
- Mixed strategy (IV crush + AI sentiment + Reddit hype)
- Technical debt and fragile code
- AI APIs add cost ($4.98/month) without value for quantitative strategy
- Difficult to test and maintain

**New System (2.0) Focus:**
- Pure quantitative VRP strategy
- Production-ready architecture (dependency injection, type safety, error handling)
- Zero AI/sentiment dependencies
- 100% testable with comprehensive error handling
- $0 API costs (only free Tradier + Alpha Vantage)

---

## System Architecture

### Design Principles

1. **Dependency Injection** - All dependencies injected via constructor (100% testable)
2. **Type Safety** - Dataclasses everywhere, no raw dicts (catch errors at compile time)
3. **Error Handling** - Explicit Result[T, Error] types (no silent failures)
4. **Clean Separation** - Domain ‚Üí Infrastructure ‚Üí Application layers
5. **Configuration** - Centralized config management (easy deployment)
6. **Observability** - Structured logging throughout (easy debugging)

### Architecture Layers

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    CLI Scripts Layer                        ‚îÇ
‚îÇ          (analyze.py, scan.py, backfill.py)                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                Application Layer (Business Logic)           ‚îÇ
‚îÇ  - TickerAnalyzer (orchestrates metrics)                    ‚îÇ
‚îÇ  - ImpliedMoveCalculator, VRPCalculator                     ‚îÇ
‚îÇ  - ConsistencyAnalyzer, TermStructureAnalyzer               ‚îÇ
‚îÇ  - SkewAnalyzer, ExecutionQualityAnalyzer                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Infrastructure Layer (External I/O)            ‚îÇ
‚îÇ  - API Clients: Tradier, Alpha Vantage                      ‚îÇ
‚îÇ  - Repositories: SQLite data access                         ‚îÇ
‚îÇ  - Cache: In-memory TTL cache                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   Domain Layer (Types)                      ‚îÇ
‚îÇ  - Types: Money, Percentage, OptionChain, ImpliedMove       ‚îÇ
‚îÇ  - Enums: Recommendation, Quality, RiskLevel, Action        ‚îÇ
‚îÇ  - Protocols: OptionsDataProvider, EarningsRepository       ‚îÇ
‚îÇ  - Errors: Result[T, Error], AppError                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Folder Structure

```
2.0/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ domain/              # Core business types (no dependencies)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types.py         # Money, Percentage, OptionChain, etc.
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ enums.py         # Recommendation, Quality, Action, etc.
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ protocols.py     # Interface definitions
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ errors.py        # Result types, AppError
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ config/              # Configuration management
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config.py        # Config with from_env(), for_testing()
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ infrastructure/      # External dependencies
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/             # API clients
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tradier.py          # Tradier options data
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ alpha_vantage.py    # Earnings dates + prices
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database/        # Data access
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ init_schema.py      # Database initialization
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ repositories/
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ earnings.py     # Historical moves
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ metadata.py     # Market cap, sector
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ prices.py       # Daily OHLCV cache
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cache/           # Caching layer
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ memory_cache.py     # TTL cache
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ application/         # Business logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ metrics/         # Metric calculators
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ implied_move.py        # Tier 1
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ vrp.py                 # Tier 1
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ consistency.py         # Tier 2
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ term_structure.py      # Tier 2
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ skew.py                # Tier 2
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ execution_quality.py   # Tier 1
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ market_cap.py          # Tier 3
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ iv_hv_ratio.py         # Tier 3
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ services/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ analyzer.py     # Unified analyzer
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ backfill.py     # Backfill service
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ watchlist.py    # Watchlist management
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ calendar.py     # Earnings calendar
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ utils/               # Utilities
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logging.py       # Structured logging
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ rate_limiter.py  # API rate limiting
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ container.py         # Dependency injection container
‚îÇ
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ unit/                # Unit tests (mocked dependencies)
‚îÇ   ‚îú‚îÄ‚îÄ integration/         # Integration tests (real DB, mocked APIs)
‚îÇ   ‚îî‚îÄ‚îÄ conftest.py          # Pytest fixtures
‚îÇ
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ analyze.py           # Analyze single ticker
‚îÇ   ‚îú‚îÄ‚îÄ scan.py              # Scan multiple tickers
‚îÇ   ‚îî‚îÄ‚îÄ backfill.py          # Backfill historical data
‚îÇ
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îî‚îÄ‚îÄ iv_crush_metrics.db  # SQLite database
‚îÇ
‚îî‚îÄ‚îÄ logs/
    ‚îî‚îÄ‚îÄ iv_crush.log
```

---

## Key Metrics (Tiers)

### Tier 1: Critical (Must Have) ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

1. **Implied Move** - ATM straddle price / stock price √ó 100
   - Source: Tradier API (real-time)
   - Defines expected move priced into options

2. **Historical Actual Move** - Past earnings price movements
   - Source: Alpha Vantage API ‚Üí SQLite cache
   - Need 4+ quarters of data

3. **VRP (Volatility Risk Premium)** - Implied / Historical
   - Calculated from #1 and #2
   - **Core edge metric**: 2.0x+ = Excellent, 1.5x+ = Good, <1.5x = Skip

4. **Liquidity** - Open interest + volume
   - Source: Tradier API
   - Filter: OI > 100, Volume > 50

5. **Bid-Ask Spread** - Execution cost
   - Source: Tradier API
   - Filter: Spread < 8% to ensure tradeability

### Tier 2: Risk Management ‚≠ê‚≠ê‚≠ê‚≠ê

6. **Term Structure** - Front month IV / Back month IV
   - Confirms event-specific premium
   - Want ratio > 1.5x (front month inflated)

7. **Put/Call IV Skew** - Directional bias
   - Extreme skew (>15 points) = directional bet, skip
   - Moderate skew (5-15) = adjust strikes

8. **Move Consistency** - Std dev / Mean of historical moves
   - Uses MAD (Median Absolute Deviation) for robustness
   - Low consistency = reduce position size

### Tier 3: Nice to Have ‚≠ê‚≠ê‚≠ê

9. **Market Cap** - Company size
   - Filter: $5B+ minimum (avoid small caps)

10. **IV/HV Ratio** - Current IV vs historical volatility
    - Confirms IV is elevated before earnings

---

## Key Architectural Improvements

### 1. Dependency Injection (Testability)

**Before:**
```python
class ImpliedMoveCalculator:
    def __init__(self):
        self.tradier = TradierAPI()  # Hard-coded, can't test
```

**After:**
```python
class ImpliedMoveCalculator:
    def __init__(self, data_provider: OptionsDataProvider):
        self.data_provider = data_provider  # Injected, 100% testable

# Testing:
mock = MockProvider()
calc = ImpliedMoveCalculator(mock)  # Easy!
```

### 2. Type Safety (Catch Errors Early)

**Before:**
```python
def calculate(...) -> dict:
    return {'implied_move': 8.5, 'straddle_cost': 10.0}

# Usage:
result['impled_move']  # TYPO! Runtime error
```

**After:**
```python
@dataclass(frozen=True)
class ImpliedMove:
    implied_move_pct: Percentage
    straddle_cost: Money
    atm_strike: Strike

def calculate(...) -> ImpliedMove:
    return ImpliedMove(
        implied_move_pct=Percentage.from_float(8.5),
        straddle_cost=Money.from_float(10.0),
        atm_strike=Strike.from_float(100)
    )

# Usage:
result.implied_move_pct  # Type-safe, autocomplete works!
```

### 3. Error Handling (No Silent Failures)

**Before:**
```python
def calculate(...):
    price = self.tradier.get_stock_price(ticker)  # Crashes on error
    return price * 2
```

**After:**
```python
def calculate(...) -> Result[float, AppError]:
    price_result = self.data_provider.get_stock_price(ticker)

    if price_result.is_err():
        return Err(price_result.error)  # Explicit error handling

    price = price_result.unwrap()
    return Ok(price * 2)
```

### 4. Configuration Management

**Before:**
```python
# Hard-coded everywhere
db_path = 'data/iv_crush_metrics.db'
vrp_threshold = 1.5
```

**After:**
```python
@dataclass(frozen=True)
class Config:
    database: DatabaseConfig
    api: APIConfig
    thresholds: ThresholdsConfig

    @classmethod
    def from_env(cls) -> 'Config':
        # Load from environment variables
        return cls(
            database=DatabaseConfig(path=Path(os.getenv('DB_PATH'))),
            thresholds=ThresholdsConfig(vrp_good=float(os.getenv('VRP_GOOD', '1.5')))
        )

# Usage:
config = Config.from_env()
threshold = config.thresholds.vrp_good
```

### 5. Caching Layer (Reduce API Calls)

**Problem:** Unified analyzer fetches same option chain 3x (implied move, skew, execution quality)

**Solution:**
```python
class CachedOptionsDataProvider:
    def __init__(self, provider: OptionsDataProvider, ttl: int = 30):
        self.provider = provider
        self.cache = TTLCache(ttl_seconds=ttl)

    def get_option_chain(self, ticker: str, exp: date) -> Result[OptionChain, Error]:
        cache_key = f"chain:{ticker}:{exp}"

        # Try cache first
        cached = self.cache.get(cache_key)
        if cached:
            return Ok(cached)

        # Fetch and cache
        result = self.provider.get_option_chain(ticker, exp)
        if result.is_ok():
            self.cache.set(cache_key, result.unwrap())

        return result
```

### 6. Dependency Injection Container

**Wires everything together:**
```python
class Container:
    def __init__(self, config: Config):
        self.config = config
        # Lazy-loaded properties

    @property
    def analyzer(self) -> TickerAnalyzer:
        if self._analyzer is None:
            self._analyzer = TickerAnalyzer(
                config=self.config,
                implied_calculator=self.implied_calculator,
                vrp_calculator=self.vrp_calculator,
                # ... all dependencies injected
            )
        return self._analyzer

# Usage:
container = Container.create_production()
analyzer = container.analyzer  # All wiring handled automatically
```

---

## Database Schema

**Single SQLite file:** `2.0/data/iv_crush_metrics.db`

### Tables (5 total)

1. **earnings_historical_moves** - Historical earnings price movements
   - ticker, earnings_date, prev_close, earnings_open/high/low/close
   - intraday_move_pct, gap_move_pct, close_move_pct
   - Index: (ticker, earnings_date DESC)

2. **ticker_metadata** - Market cap, sector (30-day cache)
   - ticker, market_cap, sector, industry, last_updated

3. **daily_prices_cache** - Daily OHLCV for HV calculation
   - ticker, date, close, volume

4. **iv_crush_log** - Trade performance tracking
   - ticker, earnings_date, entry_timestamp, iv_before/after
   - implied_move_pct, actual_move_pct, vrp_realized, trade_pnl

5. **api_rate_limit_log** - API call tracking
   - api_name, endpoint, status, timestamp

---

## API Dependencies

### Tradier (Free Tier) ‚úÖ
- **Usage:** Options chains, stock prices, Greeks
- **Rate Limit:** 120 calls/minute (generous)
- **Cost:** $0 (free tier sufficient)
- **Data:** Real-time option chains with IV, OI, volume

### Alpha Vantage (Free Tier) ‚úÖ
- **Usage:** Earnings dates, historical daily prices
- **Rate Limit:** 25 calls/day (tight)
- **Cost:** $0 (free tier)
- **Strategy:** Backfill slowly, cache aggressively

### ~~Perplexity AI~~ ‚ùå REMOVED
- **Was:** Sentiment analysis
- **Why Removed:** No value for quantitative VRP strategy
- **Savings:** $4.98/month

### ~~Reddit API~~ ‚ùå REMOVED
- **Was:** Social sentiment scraping
- **Why Removed:** VRP already captures all relevant information
- **Savings:** Development time + complexity

---

## Testing Strategy

### Unit Tests (Mocked Dependencies)

```python
def test_implied_move_basic():
    # Arrange
    mock_provider = Mock()
    mock_provider.get_option_chain.return_value = Ok(mock_chain)

    calculator = ImpliedMoveCalculator(mock_provider)

    # Act
    result = calculator.calculate('AAPL', date(2025, 1, 31))

    # Assert
    assert result.is_ok()
    assert result.unwrap().implied_move_pct.value == 10.0
```

**Coverage Target:** 80%+

### Integration Tests (Real DB, Mocked APIs)

```python
@pytest.mark.integration
def test_analyze_ticker_end_to_end(test_container):
    # Use real SQLite database (in-memory)
    # Mock API responses
    # Test full analysis flow

    result = test_container.analyzer.analyze('AAPL', earnings_date, exp)
    assert result.is_ok()
```

---

## Implementation Timeline

### Week 0: Foundation (4 days)
- Day 1: Folder structure, domain types (Money, Percentage, OptionChain, Strike)
- Day 2: Enums, protocols, error types, configuration **WITH VALIDATION**
- Day 3: Database schema, repositories (earnings, metadata, prices)
- Day 4: Alpha Vantage client + Rate limiter + Backfill service

### Week 1: Core Metrics (6 days)
- Day 1: Tradier API client + caching layer
- Day 2: ImpliedMove calculator **WITH TESTS**
- Day 3: VRP calculator **WITH TESTS**
- Day 4: Consistency analyzer **WITH TESTS**
- Day 5: Term structure + Skew analyzers **WITH TESTS**
- Day 6: Execution quality + Market cap analyzers **WITH TESTS**

### Week 2: Integration (5 days)
- Day 1: Unified TickerAnalyzer
- Day 2: DI Container + wiring
- Day 3: CLI scripts (analyze.py, scan.py, backfill.py)
- Day 4: Integration tests (end-to-end)
- Day 5: Watchlist management + earnings calendar

### Week 3: Production (6 days)
- Day 1-2: Comprehensive unit tests (80%+ coverage)
- Day 3: Backfill production data (50-100 tickers)
- Day 4: Deployment configs (Docker, systemd)
- Day 5: Monitoring + alerting setup
- Day 6: Documentation + README + backup strategy

**Total: 21 days (3 weeks)**

**Changes from Initial Plan:**
- +1 day Week 0: Alpha Vantage client, rate limiter, backfill service (critical gaps)
- +1 day Week 1: Complete Tier 2 metrics (term structure, skew, execution quality)
- +1 day Week 3: Deployment, monitoring, documentation

---

## Usage Examples

### Analyze Single Ticker

```bash
cd 2.0
python scripts/analyze.py AAPL 2025-01-30 2025-01-31

# Output:
# ============================================================
#   AAPL - 2025-01-30
# ============================================================
#
# üí∞ VRP: 2.15x (EXCELLENT)
#    Implied: 8.5%
#    Historical: 4.0%
#    Edge: 4.5%
#
# üìä Consistency: 0.25 (LOW RISK)
#    Position Size: 100%
#
# ‚úÖ TRADE
#    Position Size: 100%
#    VRP 2.15x | Edge 4.5%
```

### Scan Multiple Tickers

```bash
python scripts/scan.py --date 2025-01-30

# Output:
# Scanning 50 tickers for earnings on 2025-01-30...
#
# ‚úÖ AAPL: VRP 2.15x | TRADE (100%)
# ‚úÖ MSFT: VRP 1.85x | TRADE (80%)
# ‚ùå GOOGL: VRP 1.25x | SKIP (Insufficient edge)
# ‚úÖ NVDA: VRP 2.40x | TRADE (100%)
# ‚ùå TSLA: VRP 1.65x | SKIP (High inconsistency)
```

### Backfill Historical Data

```bash
python scripts/backfill.py --tickers AAPL MSFT GOOGL --quarters 12

# Output:
# Backfilling 3 tickers, 12 quarters each...
# ‚úì AAPL: 12 earnings backfilled
# ‚úì MSFT: 12 earnings backfilled
# ‚úì GOOGL: 11 earnings backfilled (1 missing)
# Done! 35 total earnings moves saved.
```

---

## What Makes This Production-Ready

### ‚úÖ Comprehensive Error Handling
- No silent failures
- Clear error messages with context
- Graceful degradation

### ‚úÖ Full Test Coverage
- Unit tests for all calculators
- Integration tests for end-to-end flow
- Easy to add new tests

### ‚úÖ Type Safety
- Catch errors at development time
- IDE autocomplete works perfectly
- Refactoring is safe

### ‚úÖ Observability
- Structured logging throughout
- Easy to debug production issues
- Performance monitoring ready

### ‚úÖ Maintainability
- Clear separation of concerns
- Each class has single responsibility
- Easy to add new metrics

### ‚úÖ Deployment Ready
- Environment-based configuration
- Works in dev/staging/production
- Simple to containerize (Docker)

---

## Comparison: 1.0 vs 2.0

| Aspect | 1.0 (Legacy) | 2.0 (New) |
|--------|-------------|-----------|
| **Strategy** | Mixed (VRP + AI + Reddit) | Pure quantitative VRP |
| **APIs** | Tradier + AV + Perplexity + Reddit | Tradier + AV only |
| **Cost** | $4.98/month | $0/month |
| **Architecture** | Tight coupling | Dependency injection |
| **Type Safety** | Raw dicts | Dataclasses + validation |
| **Error Handling** | None (crashes) | Result types throughout |
| **Testing** | 0% (untestable) | 80%+ coverage |
| **Configuration** | Hard-coded | Environment-based |
| **Logging** | print() statements | Structured logging |
| **Caching** | None | TTL cache layer |
| **Database** | Shared with 1.0 | Separate 2.0/data/ |
| **Maintenance** | High (technical debt) | Low (clean architecture) |

---

## Next Steps

1. **Review this overview** - Understand architecture and decisions
2. **Read detailed implementation** - See complete code in `2.0_IMPLEMENTATION.md`
3. **Start Week 0** - Create folder structure and domain types
4. **Implement incrementally** - Follow 18-day timeline with tests

Ready to start? Proceed to `2.0_IMPLEMENTATION.md` for complete code.
